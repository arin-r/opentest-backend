import express from "express";
import connectMongo from "../../../helpers/connectMongo";
import generateRandomHex from "../../../helpers/getHexId";
import Test from "../../../models/Test";
import Question from "../../../models/Question";
import { IGetUserAuthInfoRequest } from "../../../interfaces/IGetUserAuthInfoRequest";
import User from "../../../models/User";
import TestSession from "../../../models/TestSession";

const router = express.Router();

router.get("/", async (req, res) => {
  await connectMongo();
  const tests = await Test.find({}, { name: 1, hexId: 1, _id: 0 });
  console.log("tests = ", tests);
  res.status(200).json(tests);
});

//TODO: delete later
router.post("/init-test", async (req, res) => {
  try {
    await connectMongo();
    const newTestInfo = {
      name: "JEE Main 10 April, 2023",
      hexId: generateRandomHex(),
      testType: "jee-main",
      givenBy: [],
      questions: [],
    };
    const creationResponse = await Test.create(newTestInfo);
    res.status(200).json({
      message: "new test was created",
    });
  } catch (err) {
    console.log("Error while initializing new test. Err = ", err);
    res.status(500).json({
      message: "Error while initializing new test",
    });
  }
});

//TODO: work on security and only let authorized requests come. And only allow users with a role of admin to modify tests
router.put("/:testId/questions", async (req, res) => {
  try {
    const testId = req.params.testId;
    console.log("file: index.ts:61 ~ router.put ~ testId:", testId);
    //TODO: create types folder and store all types there
    const questionData = req.body as {
      statement: string;
      hexId: string;
      questionType: "mcq" | "numerical";
      options?: {
        statement: string;
        hexId: string;
      }[];
      correctAnswer: string; // hexId or a number - will have to convert string to number if option-type is numerical
    }

    // TODO: handle case for numerical questions
    console.log("questionData = ", questionData);
    console.log("questiondata.options = ", questionData.options);
    let newQuestion;
    await connectMongo();
    if (questionData.questionType === "mcq") {
      if (!questionData.options || questionData.options.length <= 1) {
        throw new Error("An MCQ question must have atleast two options");
      }
      for (let i = 0; i < questionData.options?.length!; ++i) {
        // questionData.options![i] = {statement: questionData.options![i], hexId: }
        questionData.options![i].hexId = generateRandomHex();
      }

      console.log("file: index.ts ~ router.put ~ data :", questionData);
      newQuestion = await Question.create({
        statement: questionData.statement,
        hexId: generateRandomHex(),
        questionType: questionData.questionType,
        options: questionData.options,
        correctAnswer: questionData.options[parseInt(questionData.correctAnswer)].hexId,
      });
    } else {
      newQuestion = await Question.create({
        statement: questionData.statement,
        hexId: generateRandomHex(),
        questionType: "numerical",
        correctAnswer: questionData.correctAnswer,
      });
    }

    console.log("newQuestion = ", newQuestion);
    const updateTestResponse = await Test.findOneAndUpdate(
      { hexId: testId },
      { $push: { questions: newQuestion._id } },
      { new: true }
    );

    res.status(200).json({ message: "Question has been added to test" });
  } catch (err) {
    console.log("Error while adding question to test. Err = ", err);
    res.status(500).json({
      message: "Error while initializing new test",
    });
  }
});

router.post("/:testId/session", async (req: IGetUserAuthInfoRequest, res) => {
  if (req.isAuthenticated()) {
    console.log("isAuth");
  }
  const testId = req.params.testId;
  console.log(`testId = ${testId}`);
  await connectMongo();
  const user = await User.findOne({ email: req.user?.email }, {_id: 1, ongoingTestSession: 1})
  console.log("user = ", user)
  console.log("user.ongoingTestSession = ", user?.ongoingTestSession)
  if(user?.ongoingTestSession) {
    res.status(400).json({message: "Session already exists. Cannot create two sessions at a time"})
    return;
  }
  const test = await Test.findOne({ hexId: testId }, { lean: true });
  const sessionCreationResponse = await TestSession.create({
    user: user?._id,
    sessionOf: test?._id,
    attempts: [],
    startTime: Date.now(),
    endTime: Date.now() + 10 * 60 * 1000,
  });
  const userUpdateResponse = await User.findByIdAndUpdate(user?._id, {$set: {ongoingTestSession: sessionCreationResponse._id}})
  console.log('sessionCreationResponse = ', sessionCreationResponse);
  console.log("userUpdateResponse = ", userUpdateResponse)
  res.status(200).json({});
});

router.get("/:testId/status", (req: IGetUserAuthInfoRequest, res) => {
  if(!req.isAuthenticated()) {
    res.status(401).json({message: "Unauthorized"})
  }
})
//REMINDER: Unused
router.get("/info/:testId", async (req, res) => {
  const testHexId = req.params.testId;
  await connectMongo();
  const testInfo = await Test.findOne(
    { hexId: testHexId },
    {
      _id: 0,
      givenBy: 1,
      hexId: 0,
      name: 1,
      questions: 0,
      testType: 1,
    }
  );

  res.status(200).json(testInfo);
});

module.exports = router;