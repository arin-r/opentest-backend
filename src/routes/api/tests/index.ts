import express from "express";
import connectMongo from "../../../helpers/connectMongo";
import generateRandomHex from "../../../helpers/getHexId";
import Test from "../../../models/Test";
import Question from "../../../models/Question";
import { IGetUserAuthInfoRequest } from "../../../interfaces/IGetUserAuthInfoRequest";
import User from "../../../models/User";
import TestSession from "../../../models/TestSession";
import mongoose from "mongoose";

const router = express.Router();

router.get("/", async (req, res) => {
  await connectMongo();
  const tests = await Test.find({}, { name: 1, hexId: 1, _id: 0 });
  console.log("tests = ", tests);
  res.status(200).json(tests);
});

//TODO: delete later
router.post("/init-test", async (req, res) => {
  try {
    await connectMongo();
    const newTestInfo = {
      name: "JEE Main 10 April, 2023",
      hexId: generateRandomHex(),
      testType: "jee-main",
      givenBy: [],
      questions: [],
    };
    const creationResponse = await Test.create(newTestInfo);
    res.status(200).json({
      message: "new test was created",
    });
  } catch (err) {
    console.log("Error while initializing new test. Err = ", err);
    res.status(500).json({
      message: "Error while initializing new test",
    });
  }
});

//TODO: work on security and only let authorized requests come. And only allow users with a role of admin to modify tests
router.put("/:testId/questions", async (req, res) => {
  try {
    const testId = req.params.testId;
    console.log("file: index.ts:61 ~ router.put ~ testId:", testId);
    //TODO: create types folder and store all types there
    const questionData = req.body as {
      statement: string;
      questionType: "mcq" | "numerical";
      options?: {
        statement: string;
        hexId: string;
      }[];
      correctAnswer: string; // hexId or a number - will have to convert string to number if option-type is numerical
    };
    // TODO: handle case for numerical questions
    console.log("questionData = ", questionData);
    console.log("questiondata.options = ", questionData.options);
    let newQuestion;
    await connectMongo();
    if (questionData.questionType === "mcq") {
      if (!questionData.options || questionData.options.length <= 1) {
        throw new Error("An MCQ question must have atleast two options");
      }
      for (let i = 0; i < questionData.options?.length!; ++i) {
        // questionData.options![i] = {statement: questionData.options![i], hexId: }
        questionData.options![i].hexId = generateRandomHex();
      }

      console.log("file: index.ts ~ router.put ~ data :", questionData);
      newQuestion = await Question.create({
        statement: questionData.statement,
        questionType: questionData.questionType,
        options: questionData.options,
        correctAnswer: questionData.options[parseInt(questionData.correctAnswer)].hexId,
      });
    } else {
      newQuestion = await Question.create({
        statement: questionData.statement,
        questionType: "numerical",
        correctAnswer: questionData.correctAnswer,
      });
    }

    console.log("newQuestion = ", newQuestion);
    const updateTestResponse = await Test.findOneAndUpdate(
      { hexId: testId },
      { $push: { questions: newQuestion._id } },
      { new: true }
    );

    res.status(200).json({ message: "Question has been added to test" });
  } catch (err) {
    console.log("Error while adding question to test. Err = ", err);
    res.status(500).json({
      message: "Error while initializing new test",
    });
  }
});

router.post("/:testId/session", async (req: IGetUserAuthInfoRequest, res) => {
  if (req.isAuthenticated()) {
    console.log("isAuth");
  } else {
    res.status(400).json({ message: "Must be logged in to start a test session" });
    return;
  }
  const testId = req.params.testId;
  console.log(`testId = ${testId}`);
  await connectMongo();
  const user = await User.findOne({ email: req.user?.email }, { _id: 1, ongoingTestSession: 1 });
  console.log("user = ", user);
  console.log("user.ongoingTestSession = ", user?.ongoingTestSession);
  if (user?.ongoingTestSession) {
    res
      .status(400)
      .json({ message: "Session already exists. Cannot create two sessions at a time" });
    return;
  }
  const test = await Test.findOne({ hexId: testId }, { _id: 1, questions: 1 });
  console.log("test.questions = ", test?.questions);
  const sessionCreationResponse = await TestSession.create({
    user: user?._id,
    sessionOf: test?._id,
    attempts: test?.questions.map((q: any, i: number) => {
      return {
        questionId: q._id,
        markedForReview: false,
        seen: false,
      };
    }),
    startTime: Date.now(),
    endTime: Date.now() + 3 * 60 * 1000,
  });
  const userUpdateResponse = await User.findByIdAndUpdate(user?._id, {
    $set: { ongoingTestSession: sessionCreationResponse._id },
  });
  res.status(200).json({});
});

router.get("/:testId/status", async (req: IGetUserAuthInfoRequest, res) => {
  console.log("/:testId/status being called");
  if (!req.isAuthenticated()) {
    res.status(401).json({ message: "Unauthorized. Must be logged in." });
    return;
  }
  const currentTime = new Date();
  const user = await User.findOne({ email: req.user?.email }, { ongoingTestSession: 1 });
  console.log("user = ", user);
  if (!user?.ongoingTestSession) {
    res.status(401).json({ message: "Unauthorized. User does not have ongoingTestSession" });
    return;
  }
  const session = await TestSession.findById(user?.ongoingTestSession, {
    _id: 0,
    startTime: 1,
    endTime: 1,
    sessionOf: 1,
    attempts: 1,
  });
  console.log("session = ", session);
  if (session?.startTime! > currentTime) {
    res.status(401).json({ message: "Session has not started yet" });
    return;
  }
  if (session?.endTime! < currentTime) {
    User.updateOne({ _id: user?._id }, { $unset: { ongoingTestSession: 1 } })
      .then((res) => {
        console.log("Since session had expried, it has been removed from user.ongoingsession");
      })
      .catch((err) => {
        console.log("something went wrong while removing user.ongoingsession");
      });
    res.status(401).json({ message: "Session has expired" });
    return;
  }
  const attempts = session?.attempts;
  console.log("session.attempts = ", attempts);
  res.status(200).json({
    startTime: session?.startTime,
    questions: attempts?.map((attempt) => {
      return {
        hexId: attempt.questionId.toString(),
        chosenOptionId: attempt.chosenOptionId,
        markedForReview: attempt.markedForReview,
        seen: attempt.seen,
      }
    })
  }) 
});

/** TODO: Suggestion. Move this to questions/:questionId route. A question is not test specific.
 * I mean a question can be retrived in a different context as well. It doesn't have to belong to a test,
 * which gives us reaston to make question retrieval have its own route, disconnected from tests. Also the
 * :testId parameter here is unused, unless I decide to validate if requested question does long to this test.
 * But is this validation necessary?
 */
router.get("/:testId/questions/:questionId", async (req, res) => {
  const questionId = req.params.questionId;
  await connectMongo();
  const question = await Question.findById(new mongoose.Types.ObjectId(questionId), {
    options: 1,
    questionType: 1,
    statement: 1,
  });
  if (question?.questionType === "mcq") {
    res.status(200).json({
      statement: question.statement,
      questionType: question.questionType,
      options: question.options,
    });
  } else if (question?.questionType === "numerical") {
    res.status(200).json({
      statement: question.statement,
      questionType: question.questionType,

    });
  } else {
    res.status(500).json({ message: "Unexpected condition. Questions was of unexpected type" });
  }
});
//REMINDER: Unused
router.get("/info/:testId", async (req, res) => {
  const testHexId = req.params.testId;
  await connectMongo();
  const testInfo = await Test.findOne(
    { hexId: testHexId },
    {
      _id: 0,
      givenBy: 1,
      hexId: 0,
      name: 1,
      questions: 0,
      testType: 1,
    }
  );

  res.status(200).json(testInfo);
});

module.exports = router;
